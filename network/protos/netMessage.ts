// @generated by protobuf-ts 2.9.4
// @generated from protobuf file "netMessage.proto" (syntax proto2)
// tslint:disable
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType as MessageType$ } from "@protobuf-ts/runtime";
/**
 * serial name 'io.sleekflow.infrastructure.network.proto.NetMessage'
 *
 * @generated from protobuf message NetMessage
 */
export interface NetMessage {
    /**
     * @generated from protobuf field: optional Header header = 1;
     */
    header?: Header;
    /**
     * @generated from protobuf field: optional Payload payload = 2;
     */
    payload?: Payload;
}
/**
 * serial name 'io.sleekflow.infrastructure.network.proto.Header?'
 *
 * @generated from protobuf message Header
 */
export interface Header {
    /**
     * @generated from protobuf field: optional MessageType messageType = 1;
     */
    messageType?: MessageType;
    /**
     * @generated from protobuf field: optional RequestType requestType = 2;
     */
    requestType?: RequestType;
    /**
     * @generated from protobuf field: optional string requestUuid = 3;
     */
    requestUuid?: string;
}
/**
 * serial name 'io.sleekflow.infrastructure.network.proto.payload.Payload?'
 *
 * @generated from protobuf message Payload
 */
export interface Payload {
    /**
     * @generated from protobuf field: string type = 1;
     */
    type: string;
    /**
     * decoded as message with one of these types:
     *   message CreateAccountRequestPayload, serial name 'io.sleekflow.infrastructure.network.proto.payload.CreateAccountRequestPayload'
     *   message CreateTodoTaskRequestPayload, serial name 'io.sleekflow.infrastructure.network.proto.payload.CreateTodoTaskRequestPayload'
     *   message CreateTodoTaskResponsePayload, serial name 'io.sleekflow.infrastructure.network.proto.payload.CreateTodoTaskResponsePayload'
     *   message DeleteTodoTaskRequestPayload, serial name 'io.sleekflow.infrastructure.network.proto.payload.DeleteTodoTaskRequestPayload'
     *   message DeleteTodoTaskResponsePayload, serial name 'io.sleekflow.infrastructure.network.proto.payload.DeleteTodoTaskResponsePayload'
     *   message GetTodoTaskRequestPayload, serial name 'io.sleekflow.infrastructure.network.proto.payload.GetTodoTaskRequestPayload'
     *   message GetTodoTaskResponsePayload, serial name 'io.sleekflow.infrastructure.network.proto.payload.GetTodoTaskResponsePayload'
     *   message UpdateTodoTaskRequestPayload, serial name 'io.sleekflow.infrastructure.network.proto.payload.UpdateTodoTaskRequestPayload'
     *   message UpdateTodoTaskResponsePayload, serial name 'io.sleekflow.infrastructure.network.proto.payload.UpdateTodoTaskResponsePayload'
     *
     * @generated from protobuf field: bytes value = 2;
     */
    value: Uint8Array;
}
/**
 * serial name 'io.sleekflow.infrastructure.network.proto.payload.CreateAccountRequestPayload'
 *
 * @generated from protobuf message CreateAccountRequestPayload
 */
export interface CreateAccountRequestPayload {
    /**
     * @generated from protobuf field: optional string username = 1;
     */
    username?: string;
    /**
     * @generated from protobuf field: optional string password = 2;
     */
    password?: string;
}
/**
 * serial name 'io.sleekflow.infrastructure.network.proto.payload.CreateTodoTaskRequestPayload'
 *
 * @generated from protobuf message CreateTodoTaskRequestPayload
 */
export interface CreateTodoTaskRequestPayload {
    /**
     * @generated from protobuf field: optional string name = 1;
     */
    name?: string;
    /**
     * @generated from protobuf field: optional string description = 2;
     */
    description?: string;
    /**
     * @generated from protobuf field: optional int64 dueDate = 3;
     */
    dueDate?: bigint;
    /**
     * @generated from protobuf field: optional Status status = 4;
     */
    status?: Status;
}
/**
 * serial name 'io.sleekflow.infrastructure.network.proto.payload.CreateTodoTaskResponsePayload'
 *
 * @generated from protobuf message CreateTodoTaskResponsePayload
 */
export interface CreateTodoTaskResponsePayload {
    /**
     * @generated from protobuf field: optional ErrorCode errorCode = 1;
     */
    errorCode?: ErrorCode;
    /**
     * @generated from protobuf field: optional int32 id = 2;
     */
    id?: number;
}
/**
 * serial name 'io.sleekflow.infrastructure.network.proto.payload.DeleteTodoTaskRequestPayload'
 *
 * @generated from protobuf message DeleteTodoTaskRequestPayload
 */
export interface DeleteTodoTaskRequestPayload {
    /**
     * @generated from protobuf field: optional int32 id = 1;
     */
    id?: number;
}
/**
 * serial name 'io.sleekflow.infrastructure.network.proto.payload.DeleteTodoTaskResponsePayload'
 *
 * @generated from protobuf message DeleteTodoTaskResponsePayload
 */
export interface DeleteTodoTaskResponsePayload {
    /**
     * @generated from protobuf field: optional ErrorCode errorCode = 1;
     */
    errorCode?: ErrorCode;
}
/**
 * serial name 'io.sleekflow.infrastructure.network.proto.payload.GetTodoTaskRequestPayload'
 *
 * @generated from protobuf message GetTodoTaskRequestPayload
 */
export interface GetTodoTaskRequestPayload {
    /**
     * @generated from protobuf field: optional GetTodoTaskFilter filter = 1;
     */
    filter?: GetTodoTaskFilter;
    /**
     * @generated from protobuf field: optional GetTodoTaskSort sort = 2;
     */
    sort?: GetTodoTaskSort;
}
/**
 * serial name 'io.sleekflow.infrastructure.network.proto.payload.GetTodoTaskResponsePayload'
 *
 * @generated from protobuf message GetTodoTaskResponsePayload
 */
export interface GetTodoTaskResponsePayload {
    /**
     * @generated from protobuf field: repeated TodoProtoMessage todos = 1;
     */
    todos: TodoProtoMessage[];
}
/**
 * serial name 'io.sleekflow.infrastructure.network.proto.payload.UpdateTodoTaskRequestPayload'
 *
 * @generated from protobuf message UpdateTodoTaskRequestPayload
 */
export interface UpdateTodoTaskRequestPayload {
    /**
     * @generated from protobuf field: optional int32 id = 1;
     */
    id?: number;
    /**
     * @generated from protobuf field: optional string name = 2;
     */
    name?: string;
    /**
     * @generated from protobuf field: optional string description = 3;
     */
    description?: string;
    /**
     * @generated from protobuf field: optional int64 dueDate = 4;
     */
    dueDate?: bigint;
    /**
     * @generated from protobuf field: optional Status status = 5;
     */
    status?: Status;
}
/**
 * serial name 'io.sleekflow.infrastructure.network.proto.payload.UpdateTodoTaskResponsePayload'
 *
 * @generated from protobuf message UpdateTodoTaskResponsePayload
 */
export interface UpdateTodoTaskResponsePayload {
    /**
     * @generated from protobuf field: optional ErrorCode errorCode = 1;
     */
    errorCode?: ErrorCode;
}
/**
 * serial name 'io.sleekflow.infrastructure.network.proto.payload.GetTodoTaskFilter?'
 *
 * @generated from protobuf message GetTodoTaskFilter
 */
export interface GetTodoTaskFilter {
    /**
     * @generated from protobuf field: optional int64 dueDateRangeStart = 1;
     */
    dueDateRangeStart?: bigint;
    /**
     * @generated from protobuf field: optional int64 dueDateRangeEnd = 2;
     */
    dueDateRangeEnd?: bigint;
    /**
     * WARNING: an empty collection decoded when a value is missing
     *
     * @generated from protobuf field: repeated Status statusList = 3;
     */
    statusList: Status[];
}
/**
 * serial name 'io.sleekflow.infrastructure.network.proto.payload.GetTodoTaskSort?'
 *
 * @generated from protobuf message GetTodoTaskSort
 */
export interface GetTodoTaskSort {
    /**
     * @generated from protobuf field: optional GetTodoTaskSortBy sortBy = 1;
     */
    sortBy?: GetTodoTaskSortBy;
    /**
     * @generated from protobuf field: optional GetTodoTaskSortOrder sortOrder = 2;
     */
    sortOrder?: GetTodoTaskSortOrder;
}
/**
 * serial name 'io.sleekflow.infrastructure.network.proto.payload.TodoProtoMessage'
 *
 * @generated from protobuf message TodoProtoMessage
 */
export interface TodoProtoMessage {
    /**
     * @generated from protobuf field: optional int32 id = 1;
     */
    id?: number;
    /**
     * @generated from protobuf field: optional string name = 2;
     */
    name?: string;
    /**
     * @generated from protobuf field: optional string description = 3;
     */
    description?: string;
    /**
     * @generated from protobuf field: optional int64 dueDate = 4;
     */
    dueDate?: bigint;
    /**
     * @generated from protobuf field: optional Status status = 5;
     */
    status?: Status;
}
/**
 * serial name 'io.sleekflow.infrastructure.network.proto.MessageType?'
 *
 * @generated from protobuf enum MessageType
 */
export enum MessageType {
    /**
     * @generated from protobuf enum value: Unspecified = 0;
     */
    Unspecified = 0,
    /**
     * @generated from protobuf enum value: UserInitiatedRequest = 1;
     */
    UserInitiatedRequest = 1,
    /**
     * @generated from protobuf enum value: UserInitiatedRequestResponse = 2;
     */
    UserInitiatedRequestResponse = 2,
    /**
     * @generated from protobuf enum value: ForwardedRequestResponse = 3;
     */
    ForwardedRequestResponse = 3
}
/**
 * serial name 'io.sleekflow.infrastructure.network.proto.RequestType?'
 *
 * @generated from protobuf enum RequestType
 */
export enum RequestType {
    /**
     * @generated from protobuf enum value: CreateAccount = 0;
     */
    CreateAccount = 0,
    /**
     * @generated from protobuf enum value: Login = 1;
     */
    Login = 1,
    /**
     * @generated from protobuf enum value: CreateTodoTask = 2;
     */
    CreateTodoTask = 2,
    /**
     * @generated from protobuf enum value: GetTodoTask = 3;
     */
    GetTodoTask = 3,
    /**
     * @generated from protobuf enum value: UpdateTodoTask = 4;
     */
    UpdateTodoTask = 4,
    /**
     * @generated from protobuf enum value: DeleteTodoTask = 5;
     */
    DeleteTodoTask = 5
}
/**
 * serial name 'io.sleekflow.infrastructure.network.proto.payload.messages.Status?'
 *
 * @generated from protobuf enum Status
 */
export enum Status {
    /**
     * @generated from protobuf enum value: Status_Unspecified = 0;
     */
    Status_Unspecified = 0,
    /**
     * @generated from protobuf enum value: Status_NotStarted = 1;
     */
    Status_NotStarted = 1,
    /**
     * @generated from protobuf enum value: Status_InProgress = 2;
     */
    Status_InProgress = 2,
    /**
     * @generated from protobuf enum value: Status_Completed = 3;
     */
    Status_Completed = 3
}
/**
 * serial name 'io.sleekflow.infrastructure.network.proto.payload.messages.ErrorCode?'
 *
 * @generated from protobuf enum ErrorCode
 */
export enum ErrorCode {
    /**
     * @generated from protobuf enum value: ErrorCode_Unspecified = 0;
     */
    ErrorCode_Unspecified = 0,
    /**
     * @generated from protobuf enum value: ErrorCode_Success = 1;
     */
    ErrorCode_Success = 1,
    /**
     * @generated from protobuf enum value: ErrorCode_ResourceDoesNotExist = 2;
     */
    ErrorCode_ResourceDoesNotExist = 2,
    /**
     * @generated from protobuf enum value: ErrorCode_ResourceNotUpdated = 3;
     */
    ErrorCode_ResourceNotUpdated = 3
}
/**
 * serial name 'io.sleekflow.infrastructure.network.proto.payload.GetTodoTaskSortBy?'
 *
 * @generated from protobuf enum GetTodoTaskSortBy
 */
export enum GetTodoTaskSortBy {
    /**
     * @generated from protobuf enum value: GetTodoTaskSortBy_Unspecified = 0;
     */
    GetTodoTaskSortBy_Unspecified = 0,
    /**
     * @generated from protobuf enum value: GetTodoTaskSortBy_ByName = 1;
     */
    GetTodoTaskSortBy_ByName = 1,
    /**
     * @generated from protobuf enum value: GetTodoTaskSortBy_ByDueDate = 2;
     */
    GetTodoTaskSortBy_ByDueDate = 2,
    /**
     * @generated from protobuf enum value: GetTodoTaskSortBy_ByStatus = 3;
     */
    GetTodoTaskSortBy_ByStatus = 3
}
/**
 * serial name 'io.sleekflow.infrastructure.network.proto.payload.GetTodoTaskSortOrder?'
 *
 * @generated from protobuf enum GetTodoTaskSortOrder
 */
export enum GetTodoTaskSortOrder {
    /**
     * @generated from protobuf enum value: GetTodoTaskSortOrder_Unspecified = 0;
     */
    GetTodoTaskSortOrder_Unspecified = 0,
    /**
     * @generated from protobuf enum value: GetTodoTaskSortOrder_ASC = 1;
     */
    GetTodoTaskSortOrder_ASC = 1,
    /**
     * @generated from protobuf enum value: GetTodoTaskSortOrder_DESC = 2;
     */
    GetTodoTaskSortOrder_DESC = 2
}
// @generated message type with reflection information, may provide speed optimized methods
class NetMessage$Type extends MessageType$<NetMessage> {
    constructor() {
        super("NetMessage", [
            { no: 1, name: "header", kind: "message", T: () => Header },
            { no: 2, name: "payload", kind: "message", T: () => Payload }
        ]);
    }
    create(value?: PartialMessage<NetMessage>): NetMessage {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<NetMessage>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: NetMessage): NetMessage {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional Header header */ 1:
                    message.header = Header.internalBinaryRead(reader, reader.uint32(), options, message.header);
                    break;
                case /* optional Payload payload */ 2:
                    message.payload = Payload.internalBinaryRead(reader, reader.uint32(), options, message.payload);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: NetMessage, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional Header header = 1; */
        if (message.header)
            Header.internalBinaryWrite(message.header, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* optional Payload payload = 2; */
        if (message.payload)
            Payload.internalBinaryWrite(message.payload, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message NetMessage
 */
export const NetMessage = new NetMessage$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Header$Type extends MessageType$<Header> {
    constructor() {
        super("Header", [
            { no: 1, name: "messageType", kind: "enum", opt: true, T: () => ["MessageType", MessageType] },
            { no: 2, name: "requestType", kind: "enum", opt: true, T: () => ["RequestType", RequestType] },
            { no: 3, name: "requestUuid", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Header>): Header {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<Header>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Header): Header {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional MessageType messageType */ 1:
                    message.messageType = reader.int32();
                    break;
                case /* optional RequestType requestType */ 2:
                    message.requestType = reader.int32();
                    break;
                case /* optional string requestUuid */ 3:
                    message.requestUuid = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Header, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional MessageType messageType = 1; */
        if (message.messageType !== undefined)
            writer.tag(1, WireType.Varint).int32(message.messageType);
        /* optional RequestType requestType = 2; */
        if (message.requestType !== undefined)
            writer.tag(2, WireType.Varint).int32(message.requestType);
        /* optional string requestUuid = 3; */
        if (message.requestUuid !== undefined)
            writer.tag(3, WireType.LengthDelimited).string(message.requestUuid);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message Header
 */
export const Header = new Header$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Payload$Type extends MessageType$<Payload> {
    constructor() {
        super("Payload", [
            { no: 1, name: "type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "value", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<Payload>): Payload {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.type = "";
        message.value = new Uint8Array(0);
        if (value !== undefined)
            reflectionMergePartial<Payload>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Payload): Payload {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string type */ 1:
                    message.type = reader.string();
                    break;
                case /* bytes value */ 2:
                    message.value = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Payload, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string type = 1; */
        if (message.type !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.type);
        /* bytes value = 2; */
        if (message.value.length)
            writer.tag(2, WireType.LengthDelimited).bytes(message.value);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message Payload
 */
export const Payload = new Payload$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CreateAccountRequestPayload$Type extends MessageType$<CreateAccountRequestPayload> {
    constructor() {
        super("CreateAccountRequestPayload", [
            { no: 1, name: "username", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "password", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CreateAccountRequestPayload>): CreateAccountRequestPayload {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CreateAccountRequestPayload>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CreateAccountRequestPayload): CreateAccountRequestPayload {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string username */ 1:
                    message.username = reader.string();
                    break;
                case /* optional string password */ 2:
                    message.password = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CreateAccountRequestPayload, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string username = 1; */
        if (message.username !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.username);
        /* optional string password = 2; */
        if (message.password !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.password);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CreateAccountRequestPayload
 */
export const CreateAccountRequestPayload = new CreateAccountRequestPayload$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CreateTodoTaskRequestPayload$Type extends MessageType$<CreateTodoTaskRequestPayload> {
    constructor() {
        super("CreateTodoTaskRequestPayload", [
            { no: 1, name: "name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "description", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "dueDate", kind: "scalar", opt: true, T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "status", kind: "enum", opt: true, T: () => ["Status", Status] }
        ]);
    }
    create(value?: PartialMessage<CreateTodoTaskRequestPayload>): CreateTodoTaskRequestPayload {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CreateTodoTaskRequestPayload>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CreateTodoTaskRequestPayload): CreateTodoTaskRequestPayload {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string name */ 1:
                    message.name = reader.string();
                    break;
                case /* optional string description */ 2:
                    message.description = reader.string();
                    break;
                case /* optional int64 dueDate */ 3:
                    message.dueDate = reader.int64().toBigInt();
                    break;
                case /* optional Status status */ 4:
                    message.status = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CreateTodoTaskRequestPayload, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string name = 1; */
        if (message.name !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* optional string description = 2; */
        if (message.description !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.description);
        /* optional int64 dueDate = 3; */
        if (message.dueDate !== undefined)
            writer.tag(3, WireType.Varint).int64(message.dueDate);
        /* optional Status status = 4; */
        if (message.status !== undefined)
            writer.tag(4, WireType.Varint).int32(message.status);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CreateTodoTaskRequestPayload
 */
export const CreateTodoTaskRequestPayload = new CreateTodoTaskRequestPayload$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CreateTodoTaskResponsePayload$Type extends MessageType$<CreateTodoTaskResponsePayload> {
    constructor() {
        super("CreateTodoTaskResponsePayload", [
            { no: 1, name: "errorCode", kind: "enum", opt: true, T: () => ["ErrorCode", ErrorCode] },
            { no: 2, name: "id", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<CreateTodoTaskResponsePayload>): CreateTodoTaskResponsePayload {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CreateTodoTaskResponsePayload>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CreateTodoTaskResponsePayload): CreateTodoTaskResponsePayload {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional ErrorCode errorCode */ 1:
                    message.errorCode = reader.int32();
                    break;
                case /* optional int32 id */ 2:
                    message.id = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CreateTodoTaskResponsePayload, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional ErrorCode errorCode = 1; */
        if (message.errorCode !== undefined)
            writer.tag(1, WireType.Varint).int32(message.errorCode);
        /* optional int32 id = 2; */
        if (message.id !== undefined)
            writer.tag(2, WireType.Varint).int32(message.id);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CreateTodoTaskResponsePayload
 */
export const CreateTodoTaskResponsePayload = new CreateTodoTaskResponsePayload$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DeleteTodoTaskRequestPayload$Type extends MessageType$<DeleteTodoTaskRequestPayload> {
    constructor() {
        super("DeleteTodoTaskRequestPayload", [
            { no: 1, name: "id", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<DeleteTodoTaskRequestPayload>): DeleteTodoTaskRequestPayload {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<DeleteTodoTaskRequestPayload>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DeleteTodoTaskRequestPayload): DeleteTodoTaskRequestPayload {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 id */ 1:
                    message.id = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DeleteTodoTaskRequestPayload, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 id = 1; */
        if (message.id !== undefined)
            writer.tag(1, WireType.Varint).int32(message.id);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message DeleteTodoTaskRequestPayload
 */
export const DeleteTodoTaskRequestPayload = new DeleteTodoTaskRequestPayload$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DeleteTodoTaskResponsePayload$Type extends MessageType$<DeleteTodoTaskResponsePayload> {
    constructor() {
        super("DeleteTodoTaskResponsePayload", [
            { no: 1, name: "errorCode", kind: "enum", opt: true, T: () => ["ErrorCode", ErrorCode] }
        ]);
    }
    create(value?: PartialMessage<DeleteTodoTaskResponsePayload>): DeleteTodoTaskResponsePayload {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<DeleteTodoTaskResponsePayload>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DeleteTodoTaskResponsePayload): DeleteTodoTaskResponsePayload {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional ErrorCode errorCode */ 1:
                    message.errorCode = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DeleteTodoTaskResponsePayload, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional ErrorCode errorCode = 1; */
        if (message.errorCode !== undefined)
            writer.tag(1, WireType.Varint).int32(message.errorCode);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message DeleteTodoTaskResponsePayload
 */
export const DeleteTodoTaskResponsePayload = new DeleteTodoTaskResponsePayload$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetTodoTaskRequestPayload$Type extends MessageType$<GetTodoTaskRequestPayload> {
    constructor() {
        super("GetTodoTaskRequestPayload", [
            { no: 1, name: "filter", kind: "message", T: () => GetTodoTaskFilter },
            { no: 2, name: "sort", kind: "message", T: () => GetTodoTaskSort }
        ]);
    }
    create(value?: PartialMessage<GetTodoTaskRequestPayload>): GetTodoTaskRequestPayload {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<GetTodoTaskRequestPayload>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetTodoTaskRequestPayload): GetTodoTaskRequestPayload {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional GetTodoTaskFilter filter */ 1:
                    message.filter = GetTodoTaskFilter.internalBinaryRead(reader, reader.uint32(), options, message.filter);
                    break;
                case /* optional GetTodoTaskSort sort */ 2:
                    message.sort = GetTodoTaskSort.internalBinaryRead(reader, reader.uint32(), options, message.sort);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetTodoTaskRequestPayload, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional GetTodoTaskFilter filter = 1; */
        if (message.filter)
            GetTodoTaskFilter.internalBinaryWrite(message.filter, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* optional GetTodoTaskSort sort = 2; */
        if (message.sort)
            GetTodoTaskSort.internalBinaryWrite(message.sort, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message GetTodoTaskRequestPayload
 */
export const GetTodoTaskRequestPayload = new GetTodoTaskRequestPayload$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetTodoTaskResponsePayload$Type extends MessageType$<GetTodoTaskResponsePayload> {
    constructor() {
        super("GetTodoTaskResponsePayload", [
            { no: 1, name: "todos", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TodoProtoMessage }
        ]);
    }
    create(value?: PartialMessage<GetTodoTaskResponsePayload>): GetTodoTaskResponsePayload {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.todos = [];
        if (value !== undefined)
            reflectionMergePartial<GetTodoTaskResponsePayload>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetTodoTaskResponsePayload): GetTodoTaskResponsePayload {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated TodoProtoMessage todos */ 1:
                    message.todos.push(TodoProtoMessage.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetTodoTaskResponsePayload, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated TodoProtoMessage todos = 1; */
        for (let i = 0; i < message.todos.length; i++)
            TodoProtoMessage.internalBinaryWrite(message.todos[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message GetTodoTaskResponsePayload
 */
export const GetTodoTaskResponsePayload = new GetTodoTaskResponsePayload$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UpdateTodoTaskRequestPayload$Type extends MessageType$<UpdateTodoTaskRequestPayload> {
    constructor() {
        super("UpdateTodoTaskRequestPayload", [
            { no: 1, name: "id", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "description", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "dueDate", kind: "scalar", opt: true, T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 5, name: "status", kind: "enum", opt: true, T: () => ["Status", Status] }
        ]);
    }
    create(value?: PartialMessage<UpdateTodoTaskRequestPayload>): UpdateTodoTaskRequestPayload {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<UpdateTodoTaskRequestPayload>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UpdateTodoTaskRequestPayload): UpdateTodoTaskRequestPayload {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 id */ 1:
                    message.id = reader.int32();
                    break;
                case /* optional string name */ 2:
                    message.name = reader.string();
                    break;
                case /* optional string description */ 3:
                    message.description = reader.string();
                    break;
                case /* optional int64 dueDate */ 4:
                    message.dueDate = reader.int64().toBigInt();
                    break;
                case /* optional Status status */ 5:
                    message.status = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UpdateTodoTaskRequestPayload, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 id = 1; */
        if (message.id !== undefined)
            writer.tag(1, WireType.Varint).int32(message.id);
        /* optional string name = 2; */
        if (message.name !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.name);
        /* optional string description = 3; */
        if (message.description !== undefined)
            writer.tag(3, WireType.LengthDelimited).string(message.description);
        /* optional int64 dueDate = 4; */
        if (message.dueDate !== undefined)
            writer.tag(4, WireType.Varint).int64(message.dueDate);
        /* optional Status status = 5; */
        if (message.status !== undefined)
            writer.tag(5, WireType.Varint).int32(message.status);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message UpdateTodoTaskRequestPayload
 */
export const UpdateTodoTaskRequestPayload = new UpdateTodoTaskRequestPayload$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UpdateTodoTaskResponsePayload$Type extends MessageType$<UpdateTodoTaskResponsePayload> {
    constructor() {
        super("UpdateTodoTaskResponsePayload", [
            { no: 1, name: "errorCode", kind: "enum", opt: true, T: () => ["ErrorCode", ErrorCode] }
        ]);
    }
    create(value?: PartialMessage<UpdateTodoTaskResponsePayload>): UpdateTodoTaskResponsePayload {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<UpdateTodoTaskResponsePayload>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UpdateTodoTaskResponsePayload): UpdateTodoTaskResponsePayload {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional ErrorCode errorCode */ 1:
                    message.errorCode = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UpdateTodoTaskResponsePayload, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional ErrorCode errorCode = 1; */
        if (message.errorCode !== undefined)
            writer.tag(1, WireType.Varint).int32(message.errorCode);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message UpdateTodoTaskResponsePayload
 */
export const UpdateTodoTaskResponsePayload = new UpdateTodoTaskResponsePayload$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetTodoTaskFilter$Type extends MessageType$<GetTodoTaskFilter> {
    constructor() {
        super("GetTodoTaskFilter", [
            { no: 1, name: "dueDateRangeStart", kind: "scalar", opt: true, T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "dueDateRangeEnd", kind: "scalar", opt: true, T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "statusList", kind: "enum", repeat: 2 /*RepeatType.UNPACKED*/, T: () => ["Status", Status] }
        ]);
    }
    create(value?: PartialMessage<GetTodoTaskFilter>): GetTodoTaskFilter {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.statusList = [];
        if (value !== undefined)
            reflectionMergePartial<GetTodoTaskFilter>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetTodoTaskFilter): GetTodoTaskFilter {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int64 dueDateRangeStart */ 1:
                    message.dueDateRangeStart = reader.int64().toBigInt();
                    break;
                case /* optional int64 dueDateRangeEnd */ 2:
                    message.dueDateRangeEnd = reader.int64().toBigInt();
                    break;
                case /* repeated Status statusList */ 3:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.statusList.push(reader.int32());
                    else
                        message.statusList.push(reader.int32());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetTodoTaskFilter, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int64 dueDateRangeStart = 1; */
        if (message.dueDateRangeStart !== undefined)
            writer.tag(1, WireType.Varint).int64(message.dueDateRangeStart);
        /* optional int64 dueDateRangeEnd = 2; */
        if (message.dueDateRangeEnd !== undefined)
            writer.tag(2, WireType.Varint).int64(message.dueDateRangeEnd);
        /* repeated Status statusList = 3; */
        for (let i = 0; i < message.statusList.length; i++)
            writer.tag(3, WireType.Varint).int32(message.statusList[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message GetTodoTaskFilter
 */
export const GetTodoTaskFilter = new GetTodoTaskFilter$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetTodoTaskSort$Type extends MessageType$<GetTodoTaskSort> {
    constructor() {
        super("GetTodoTaskSort", [
            { no: 1, name: "sortBy", kind: "enum", opt: true, T: () => ["GetTodoTaskSortBy", GetTodoTaskSortBy] },
            { no: 2, name: "sortOrder", kind: "enum", opt: true, T: () => ["GetTodoTaskSortOrder", GetTodoTaskSortOrder] }
        ]);
    }
    create(value?: PartialMessage<GetTodoTaskSort>): GetTodoTaskSort {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<GetTodoTaskSort>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetTodoTaskSort): GetTodoTaskSort {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional GetTodoTaskSortBy sortBy */ 1:
                    message.sortBy = reader.int32();
                    break;
                case /* optional GetTodoTaskSortOrder sortOrder */ 2:
                    message.sortOrder = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetTodoTaskSort, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional GetTodoTaskSortBy sortBy = 1; */
        if (message.sortBy !== undefined)
            writer.tag(1, WireType.Varint).int32(message.sortBy);
        /* optional GetTodoTaskSortOrder sortOrder = 2; */
        if (message.sortOrder !== undefined)
            writer.tag(2, WireType.Varint).int32(message.sortOrder);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message GetTodoTaskSort
 */
export const GetTodoTaskSort = new GetTodoTaskSort$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TodoProtoMessage$Type extends MessageType$<TodoProtoMessage> {
    constructor() {
        super("TodoProtoMessage", [
            { no: 1, name: "id", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "description", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "dueDate", kind: "scalar", opt: true, T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 5, name: "status", kind: "enum", opt: true, T: () => ["Status", Status] }
        ]);
    }
    create(value?: PartialMessage<TodoProtoMessage>): TodoProtoMessage {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<TodoProtoMessage>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TodoProtoMessage): TodoProtoMessage {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 id */ 1:
                    message.id = reader.int32();
                    break;
                case /* optional string name */ 2:
                    message.name = reader.string();
                    break;
                case /* optional string description */ 3:
                    message.description = reader.string();
                    break;
                case /* optional int64 dueDate */ 4:
                    message.dueDate = reader.int64().toBigInt();
                    break;
                case /* optional Status status */ 5:
                    message.status = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TodoProtoMessage, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 id = 1; */
        if (message.id !== undefined)
            writer.tag(1, WireType.Varint).int32(message.id);
        /* optional string name = 2; */
        if (message.name !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.name);
        /* optional string description = 3; */
        if (message.description !== undefined)
            writer.tag(3, WireType.LengthDelimited).string(message.description);
        /* optional int64 dueDate = 4; */
        if (message.dueDate !== undefined)
            writer.tag(4, WireType.Varint).int64(message.dueDate);
        /* optional Status status = 5; */
        if (message.status !== undefined)
            writer.tag(5, WireType.Varint).int32(message.status);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TodoProtoMessage
 */
export const TodoProtoMessage = new TodoProtoMessage$Type();
